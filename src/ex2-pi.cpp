// Modified from the examples created by Tim Mattson
// as found at https://github.com/HandsOnOpenCL/
// This work is licensed under the Creative Commons Attribution 3.0 Unported License.
//
// To view a copy of this license, visit http ://creativecommons.org/licenses/by/3.0/
// or send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <CL/cl.h>

void exitmsg(const char *msg){ printf("%s\n", msg); exit(EXIT_FAILURE); }
void checkError(cl_int status, const char *msg) { if (status != CL_SUCCESS) exitmsg(msg); }

const char *src =
"void reduce(                                                \n"
"	__local float* local_sums,                               \n"
"	__global float* partial_sums)                            \n"
"{                                                           \n"
"	int num_wrk_items = get_local_size(0);                   \n"
"	int local_id = get_local_id(0);                          \n"
"	int group_id = get_group_id(0);                          \n"
"	float sum;                                               \n"
"	int i;                                                   \n"
"	if (local_id == 0) {                                     \n"
"		sum = 0.0f;                                          \n"
"		for (i = 0; i < num_wrk_items; i++) {                \n"
"			sum += local_sums[i];                            \n"
"		}                                                    \n"
"		partial_sums[group_id] = sum;                        \n"
"	}                                                        \n"
"}                                                           \n"
"                                                            \n"
"__kernel void pi(                                           \n"
"	const int stepsPerItem,                                  \n"
"	const float dx,                                          \n"
"	__local float* local_sums,                               \n"
"	__global float* partial_sums)                            \n"
"{                                                           \n"
"	int num_wrk_items = get_local_size(0);                   \n"
"	int local_id = get_local_id(0);                          \n"
"	int group_id = get_group_id(0);                          \n"
"	float x, accum = 0.0f;                                   \n"
"	int i, istart, iend;                                     \n"
"	istart = (group_id * num_wrk_items + local_id) * stepsPerItem; \n"
"	iend = istart + stepsPerItem;                                  \n"
"	for (i = istart; i < iend; i++) {                        \n"
"		x = (i + 0.5f) * dx;                                 \n"
"		accum += 4.0 / (1.0f + x*x);                         \n"
"	}                                                        \n"
"	local_sums[local_id] = accum;                            \n"
"	barrier(CLK_LOCAL_MEM_FENCE);                            \n"
"	reduce(local_sums, partial_sums);                        \n"
"}                                                           \n"
;

int main(int argc, char *argv[])
{
	// Algorithm input parameters
	int numStepsAskedFor = 512 * 512 * 512;
	int stepsPerItem     = 262144;

	// Boilerplate...
	cl_int err;
	cl_platform_id platform; err = clGetPlatformIDs(1, &platform, NULL);
	cl_device_id device; err = clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL, 1, &device, NULL);
	cl_context_properties cps[3] = { CL_CONTEXT_PLATFORM, (cl_context_properties)platform, 0 };
	cl_context context = clCreateContext(cps, 1, &device, NULL, NULL, &err);
	cl_command_queue commands = clCreateCommandQueue(context, device, 0, &err);

	// Create the compute program from the source buffer
	cl_program program = clCreateProgramWithSource(context, 1, (const char **)&src, NULL, &err);
	checkError(err, "Creating program");

	// Build the program. If things go wrong (and they will go wrong!)
	// opencl provides a method that allows extraction of the error message
	// generated by the device code compiler.
	err = clBuildProgram(program, 0, NULL, NULL, NULL, NULL);
	if (err != CL_SUCCESS) {
		size_t len;	char buffer[2048];
		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, sizeof(buffer), buffer, &len);
		printf("%s\n", buffer);
		return EXIT_FAILURE;
	}
	// Extract the kernel (function) from the program (library) 
	cl_kernel kernel_pi = clCreateKernel(program, "pi", &err);
	checkError(err, "Creating kernel");

	// OpenCL Provides convenience methods that help tune the execution on a given device.
	size_t ItemsPerWorkGroup = 8;
	err = clGetKernelWorkGroupInfo(kernel_pi, device, CL_KERNEL_WORK_GROUP_SIZE, sizeof(size_t), &ItemsPerWorkGroup, NULL);
	checkError(err, "Getting kernel work group info");
	printf("Work group size as given by clGetKernelWorkGroupInfo: %d.\n", ItemsPerWorkGroup);

	// Compute the actual number of numSteps to be an integer multiple of the number of workgroups
	size_t numWorkGroups = numStepsAskedFor / (ItemsPerWorkGroup*stepsPerItem);
	if (numWorkGroups < 1) numWorkGroups = 1;

	int numSteps = ItemsPerWorkGroup * stepsPerItem * numWorkGroups;
	float dx     = 1.0f / (float)numSteps;

	// Allocate memory for the partial sums on the device
	cl_mem d_partial_sums = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(float) * numWorkGroups, NULL, &err);
	checkError(err, "Creating buffer d_partial_sums");

	// Set kernel arguments
	clSetKernelArg(kernel_pi, 0, sizeof(int),                     &stepsPerItem);
	clSetKernelArg(kernel_pi, 1, sizeof(float),                   &dx);
	// Local memory is not allocated from within the host code. Instead,
	// the OpenCL runtime will make sure it is visible to the workgroup
	// it belongs to when that workgroup is active.
	clSetKernelArg(kernel_pi, 2, sizeof(float) * ItemsPerWorkGroup, NULL);
	clSetKernelArg(kernel_pi, 3, sizeof(cl_mem), &d_partial_sums);

	size_t global = numSteps / stepsPerItem; //(= numItems)
	size_t local = ItemsPerWorkGroup;

	printf(" %ld work-groups of size %ld will compute the integrand in %d points\n", numWorkGroups, ItemsPerWorkGroup, numSteps);
	err = clEnqueueNDRangeKernel(commands, kernel_pi, 1, NULL, &global, &local, 0, NULL, NULL);
	checkError(err, "Enqueueing kernel");

	// One output per workgroup
	float *h_partialSum = (float*)calloc(sizeof(float), numWorkGroups);
	err = clEnqueueReadBuffer(commands, d_partial_sums,	CL_TRUE, 0,	sizeof(float) * numWorkGroups, h_partialSum, 0, NULL, NULL);
	checkError(err, "Reading back d_partial_sums");

	// The final reduction putting the workgroup results
	// together is done by the CPU.
	float pi_res = 0.0f;
	for (unsigned int i = 0; i < numWorkGroups; i++)
		pi_res += h_partialSum[i];
	pi_res *= dx;

	printf(" pi approx %f\n", pi_res);

	clReleaseMemObject(d_partial_sums);
	clReleaseProgram(program);
	clReleaseKernel(kernel_pi);
	clReleaseCommandQueue(commands);
	clReleaseContext(context);
	free(h_partialSum);

	return 0;
}
